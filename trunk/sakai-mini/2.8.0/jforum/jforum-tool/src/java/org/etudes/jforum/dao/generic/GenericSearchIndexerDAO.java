/**********************************************************************************
 * $URL: https://source.sakaiproject.org/contrib/etudes/sakai-jforum/tags/2.8.1/jforum-tool/src/java/org/etudes/jforum/dao/generic/GenericSearchIndexerDAO.java $ 
 * $Id: GenericSearchIndexerDAO.java 55493 2008-12-01 22:55:48Z murthy@etudes.org $ 
 *********************************************************************************** 
 * 
 * Copyright (c) 2008 Etudes, Inc. 
 * 
 * Licensed under the Apache License, Version 2.0 (the "License"); 
 * you may not use this file except in compliance with the License. 
 * You may obtain a copy of the License at 
 * 
 * http://www.apache.org/licenses/LICENSE-2.0 
 * 
 * Unless required by applicable law or agreed to in writing, software 
 * distributed under the License is distributed on an "AS IS" BASIS, 
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. 
 * See the License for the specific language governing permissions and 
 * limitations under the License. 
 * 
 * Portions completed before July 1, 2004 Copyright (c) 2003, 2004 Rafael Steil, All rights reserved, licensed under the BSD license. 
 * http://www.opensource.org/licenses/bsd-license.php 
 * 
 * Redistribution and use in source and binary forms, 
 * with or without modification, are permitted provided 
 * that the following conditions are met: 
 * 
 * 1) Redistributions of source code must retain the above 
 * copyright notice, this list of conditions and the 
 * following disclaimer. 
 * 2) Redistributions in binary form must reproduce the 
 * above copyright notice, this list of conditions and 
 * the following disclaimer in the documentation and/or 
 * other materials provided with the distribution. 
 * 3) Neither the name of "Rafael Steil" nor 
 * the names of its contributors may be used to endorse 
 * or promote products derived from this software without 
 * specific prior written permission. 
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT 
 * HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, 
 * BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF 
 * MERCHANTABILITY AND FITNESS FOR A PARTICULAR 
 * PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL 
 * THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE 
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, 
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES 
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF 
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
 * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER 
 * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER 
 * IN CONTRACT, STRICT LIABILITY, OR TORT 
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN 
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF 
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE 
 ***********************************************************************************/
package org.etudes.jforum.dao.generic;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.StringTokenizer;
import java.util.regex.Pattern;

import org.etudes.jforum.entities.Post;
import org.etudes.jforum.util.preferences.ConfigKeys;
import org.etudes.jforum.util.preferences.SystemGlobals;


/**
 * @author Rafael Steil
 */
public class GenericSearchIndexerDAO extends AutoKeys implements org.etudes.jforum.dao.SearchIndexerDAO
{
	private Connection conn;
	
	/**
	 * @see org.etudes.jforum.dao.SearchIndexerDAO#setConnection(java.sql.Connection)
	 */
	public void setConnection(Connection conn)
	{
		this.conn = conn;
	}
	
	/**
	 * @see org.etudes.jforum.dao.SearchIndexerDAO#indexSearchWords(java.util.List)
	 */
	public void insertSearchWords(List posts) throws Exception
	{
		// Prepare statements
		PreparedStatement insert = this.getStatementForAutoKeys("SearchModel.insertWords", this.conn);
		PreparedStatement existing = this.conn.prepareStatement(
						SystemGlobals.getSql("SearchModel.searchExistingWord"));
		
		PreparedStatement existingAssociation = this.conn.prepareStatement(
						SystemGlobals.getSql("SearchModel.searchExistingAssociation"));
		
		PreparedStatement wordToPost = this.conn.prepareStatement(
						SystemGlobals.getSql("SearchModel.associateWordToPost"));
		
		Pattern pattern = Pattern.compile("[\\.\\\\\\/~^&\\(\\)-_+=!@#$%\"\'\\[\\]\\{\\}?<:>,*¡"
				+ "A¡B¡C¡D¡E¡F¡G¡H¡I¡J¡K¡L¡U¡Z¡]¡^¡a¡b¡e¡f¡i¡j¡m¡n¡q¡r¡u¡v¡y¡z¡£¡¤¡¥¡¦¡§¡¨¡©¡ª¡«¡¬\n\r\t]");
		
		this.setAutoGeneratedKeysQuery(SystemGlobals.getSql("SearchModel.lastGeneratedWordId"));
		
		int minWordSize = SystemGlobals.getIntValue(ConfigKeys.SEARCH_MIN_WORD_SIZE);
		
		// Process all posts
		for (Iterator iter = posts.iterator(); iter.hasNext(); ) {
			Post post = (Post)iter.next();
			
			existingAssociation.setInt(2, post.getId());
			wordToPost.setInt(1, post.getId());
			
			String str = post.getText() + " " + post.getSubject();
			str = pattern.matcher(str).replaceAll(" ");
			
			StringTokenizer tok = new StringTokenizer(str, " ");
			while (tok.hasMoreTokens()) {
				String word = tok.nextToken().trim();
				
				// Skip words less than "n" chars
				if (word.length() < minWordSize) {
					continue;
				}
				
				// Trucate words longer than 100 chars
				if (word.length() > 100) {
					word = word.substring(0, 100); 
				}
				
				// Verify if the current word is not in the database before proceeding
				int hash = word.hashCode();
				existing.setInt(1, hash);
				ResultSet rs = existing.executeQuery();

				if (!rs.next()) {
					// The word is not in the database. Insert it now
					insert.setInt(1, hash);
					insert.setString(2, word);
					int wordId = this.executeAutoKeysQuery(insert, this.conn);

					// Associate the current word to the post
					this.associateWordToPost(wordToPost, word, wordId, post);
				}
				else {
					// The word is already in the database ( jforum_search_words )
					// Check then if the current post is not already associated to the word
					int wordId = rs.getInt("word_id");
					existingAssociation.setInt(1, wordId);
					
					ResultSet rsa = existingAssociation.executeQuery();
					if (!rsa.next()) {
						// Assoacite the post to the word
						this.associateWordToPost(wordToPost, word, wordId, post);
					}
					rsa.close();
				}
				
				rs.close();
			}
		}
		
		insert.close();
		existing.close();
		existingAssociation.close();
		wordToPost.close();
	}
	
	/**
	 * @see org.etudes.jforum.dao.SearchIndexerDAO#insertSearchWords(org.etudes.jforum.entities.Post)
	 */
	public void insertSearchWords(final Post post) throws Exception
	{
		this.insertSearchWords(new ArrayList() {{ add(post); }});
	}
	
	private void associateWordToPost(PreparedStatement p, String word, int wordId, Post post) throws Exception
	{
		p.setInt(2, wordId);
		
		String subject = post.getSubject();
		int inSubject = 0;
		if (subject != null && !subject.equals("")) {
			inSubject = subject.indexOf(word) > -1 ? 1 : 0;
		}
		
		p.setInt(3, inSubject);
		p.executeUpdate();
	}
}
